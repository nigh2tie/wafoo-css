<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>スケジュール - wafoo-css</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <meta name="robots" content="noindex,nofollow" />
    <link rel="stylesheet" href="../dist/wafoo.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lucide/0.263.1/umd/lucide.js"></script>
    <script src="../dist/wafoo.js"></script>
    <style>
      body {
        margin: 0;
      }
      .wf-schedule__mode-button {
        text-align: left;
      }
      .is-hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <a href="#main" class="wf-sr-only">メインコンテンツへスキップ</a>
    <header class="wf-header-noren" role="banner">
      <div class="wf-container" style="padding: 0"><h1>スケジュール</h1></div>
    </header>
    <main class="wf-container" role="main" id="main">
      <div class="wf-card wf-mb-4">
        <div class="wf-schedule" data-wf-schedule data-wf-schedule-mode="daily" data-wf-schedule-interval="60" data-wf-schedule-range="all-day">
          <!-- ヘッダー -->
          <div class="wf-flex wf-items-center wf-justify-center wf-gap-2 wf-mb-4">
            <i data-lucide="calendar" style="width: 24px; height: 24px; color: var(--wf-color-accent)"></i>
            <h2 style="font-size: 1.25rem; font-weight: bold; color: var(--wf-color-accent); margin: 0">候補日選択</h2>
          </div>

          <!-- モード選択 -->
          <div class="wf-mb-6">
            <label class="wf-label">表示モード</label>
            <div class="wf-schedule__mode-grid">
              <button class="wf-schedule__mode-button is-active" id="daily-mode-btn">
                <div class="wf-schedule__mode-title">1日単位指定</div>
                <div class="wf-schedule__mode-desc">日付を選択してタイムテーブルで指定</div>
              </button>
              <button class="wf-schedule__mode-button" id="weekly-mode-btn">
                <div class="wf-schedule__mode-title">1週間単位指定</div>
                <div class="wf-schedule__mode-desc">週表示で複数日を一度に指定</div>
              </button>
            </div>
          </div>

          <!-- 設定エリア -->
          <div class="wf-schedule__settings-grid">
            <!-- 日付選択（日単位モードのみ） -->
            <div id="date-selector">
              <label class="wf-label" for="selected-date">日付を選択</label>
              <input type="date" class="wf-input" id="selected-date" />
            </div>
            <div>
              <label class="wf-label" for="time-range">時間レンジ</label>
              <select class="wf-select" id="time-range">
                <option value="all-day">24時間表示</option>
                <option value="work1">勤怠：ノーマル</option>
                <option value="work2">勤怠：モダン</option>
              </select>
            </div>
            <div>
              <label class="wf-label" for="time-interval">時間刻み</label>
              <select class="wf-select" id="time-interval">
                <option value="60">60分刻み</option>
                <option value="30">30分刻み</option>
                <option value="15">15分刻み</option>
              </select>
            </div>
            <div>
              <label class="wf-label">出力オプション</label>
              <div class="wf-flex wf-flex-col wf-gap-2">
                <label class="wf-check">
                  <input type="checkbox" class="wf-checkbox" id="show-weekday" checked />
                  <span>曜日を表示</span>
                </label>
                <label class="wf-check">
                  <input type="checkbox" class="wf-checkbox" id="use-template" />
                  <span>ビジネステンプレート</span>
                </label>
              </div>
            </div>
          </div>

          <!-- アクションボタン -->
          <div class="wf-schedule__action-buttons">
            <button class="wf-btn wf-btn-primary is-hidden" id="current-week-btn">今週を表示</button>
            <button class="wf-btn wf-btn-danger" id="clear-btn">全てクリア</button>
          </div>

          <!-- 週ナビゲーション -->
          <div class="wf-schedule__week-nav is-hidden" id="week-nav">
            <div class="wf-schedule__week-nav-left">
              <button class="wf-schedule__nav-btn" id="prev-week-btn">
                <i data-lucide="chevron-left"></i>
              </button>
              <div class="wf-schedule__week-title" id="week-title"></div>
              <button class="wf-schedule__nav-btn" id="next-week-btn">
                <i data-lucide="chevron-right"></i>
              </button>
            </div>
            <div class="wf-schedule__status-text">
              <span id="lock-status" class="wf-schedule__status-locked is-hidden">設定固定中</span>
            </div>
          </div>

          <!-- 日単位モード：タイムテーブル -->
          <div class="wf-schedule__daily-section" id="daily-section">
            <div class="wf-schedule__daily-header">
              <div class="wf-schedule__daily-title">
                <i data-lucide="clock" style="width: 20px; height: 20px"></i>
                空き時間を選択（ドラッグまたはクリックで選択）
              </div>
              <div class="wf-schedule__status-text">
                <span id="daily-lock-status" class="wf-schedule__status-locked is-hidden">設定固定中</span>
              </div>
            </div>
            <div class="wf-schedule__time-grid wf-schedule__time-grid--cols-8" id="daily-time-grid"></div>
            <div class="wf-schedule__help-text" id="help-text">クリックまたはドラッグして時間帯を選択してください</div>
          </div>

          <!-- 週単位モード：週カレンダー -->
          <div class="wf-schedule__weekly-calendar is-hidden" id="weekly-section">
            <div class="wf-schedule__calendar-header" id="calendar-header"></div>
            <div class="wf-schedule__calendar-grid" id="calendar-grid"></div>
          </div>
        </div>
      </div>

      <!-- 生成されたテキスト -->
      <div class="wf-card wf-schedule__output-section is-hidden" id="output-section">
        <div class="wf-schedule__output-header">
          <div class="wf-schedule__output-title">生成されたテキスト</div>
          <button class="wf-btn wf-btn-primary" id="copy-btn">
            <i data-lucide="copy" style="width: 16px; height: 16px"></i>
            <span id="copy-text">コピー</span>
          </button>
        </div>
        <div class="wf-schedule__output-box">
          <div class="wf-schedule__output-text" id="output-text"></div>
        </div>
      </div>

      <p class="wf-text-sm wf-text-muted wf-mt-4">
      <a class="wf-link" href="./showcase-wafu.html">ショーケースへ戻る</a>
      </p>
    </main>

    <script>
      // グローバル状態とスケジュールインスタンス
      let scheduleInstance = null;
      let currentMode = "daily";
      let state = {
        isTimeIntervalLocked: false,
        isTimeRangeLocked: false,
        showWeekday: true,
        useTemplate: false,
        rangeSelectionStart: null,
        isRangeSelecting: false
      };

      // 範囲選択メッセージ表示
      function showRangeSelectionMessage() {
        hideRangeSelectionMessage();
        const message = document.createElement("div");
        message.id = "range-selection-message";
        message.style.cssText =
          "position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--wf-primary-bg); color: var(--wf-primary-fg); padding: 1rem 2rem; border-radius: var(--wf-radius-md); font-size: var(--wf-font-sm); z-index: 1000; box-shadow: var(--wf-shadow-lg); animation: fadeIn 0.3s ease-out; display: flex; flex-direction: column; align-items: center; gap: 0.75rem; max-width: 280px; text-align: center;";
        message.innerHTML =
          '<div>終了時間をタップしてください</div><button onclick="cancelRangeSelection()" style="background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); color: white; padding: 0.5rem 1rem; border-radius: 0.25rem; font-size: 0.75rem; cursor: pointer;">キャンセル（単発選択）</button>';
        if (!document.getElementById("range-animation-style")) {
          const style = document.createElement("style");
          style.id = "range-animation-style";
          style.textContent =
            "@keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }";
          document.head.appendChild(style);
        }
        document.body.appendChild(message);
      }

      function hideRangeSelectionMessage() {
        const message = document.getElementById("range-selection-message");
        if (message) message.remove();
      }

      function cancelRangeSelection() {
        if (state.rangeSelectionStart && scheduleInstance) {
          const key = `${state.rangeSelectionStart.date}-${state.rangeSelectionStart.time}`;
          const slots = scheduleInstance.getSelectedSlots();
          // 開始点が選択されていない場合は、単発で選択する
          if (!slots.includes(key)) {
            // 既存の選択を保持しつつ、開始点を追加
            // 実際の実装では、APIにtoggleSlot()メソッドが必要
            // 暫定実装: 開始点を選択状態にするため、内部状態を直接操作
            // ただし、これはAPIの制限により完全には実装できない
            // キャンセル時は開始点を選択状態にしない（元の仕様に従う）
          }
        }
        state.rangeSelectionStart = null;
        state.isRangeSelecting = false;
        hideRangeSelectionMessage();
        // 表示を更新（範囲選択開始状態を解除）
        if (scheduleInstance) {
          scheduleInstance.setMode(currentMode);
        }
      }

      function updateLockControls() {
        document.getElementById("time-range").disabled = state.isTimeRangeLocked;
        document.getElementById("time-interval").disabled = state.isTimeIntervalLocked;
        const lockStatus = state.isTimeIntervalLocked || state.isTimeRangeLocked;
        document.getElementById("lock-status").classList.toggle("is-hidden", !lockStatus);
        document.getElementById("daily-lock-status").classList.toggle("is-hidden", !lockStatus);
      }

      function updateModeButtons() {
        document.getElementById("daily-mode-btn").classList.toggle("is-active", currentMode === "daily");
        document.getElementById("weekly-mode-btn").classList.toggle("is-active", currentMode === "weekly");
      }

      function getEndTime(startTime, interval) {
        const [hour, minute] = startTime.split(":").map(Number);
        let endMinute = minute + interval;
        let endHour = hour;
        if (endMinute >= 60) {
          endMinute -= 60;
          endHour += 1;
        }
        return `${endHour.toString().padStart(2, "0")}:${endMinute.toString().padStart(2, "0")}`;
      }

      function generateText() {
        if (!scheduleInstance) return "";
        const slots = scheduleInstance.getSelectedSlots();
        if (slots.length === 0) return "";

        const slotsByDate = {};
        slots.forEach(slot => {
          const parts = slot.split("-");
          const date = parts.slice(0, 3).join("-");
          const time = parts.slice(3).join(":");
          if (!slotsByDate[date]) slotsByDate[date] = [];
          slotsByDate[date].push(time);
        });

        const results = [];
        Object.keys(slotsByDate)
          .sort()
          .forEach(date => {
            const times = slotsByDate[date].sort();
            const ranges = [];
            let rangeStart = times[0];
            let rangeEnd = times[0];
            const interval = parseInt(document.getElementById("time-interval").value) || 60;

            for (let i = 1; i < times.length; i++) {
              const [prevHour, prevMinute] = times[i - 1].split(":").map(Number);
              const [currHour, currMinute] = times[i].split(":").map(Number);
              const prevTotalMinutes = prevHour * 60 + prevMinute;
              const currTotalMinutes = currHour * 60 + currMinute;

              if (currTotalMinutes === prevTotalMinutes + interval) {
                rangeEnd = times[i];
              } else {
                const endTime = getEndTime(rangeEnd, interval);
                ranges.push(`${rangeStart}-${endTime}`);
                rangeStart = times[i];
                rangeEnd = times[i];
              }
            }
            if (rangeStart) {
              const endTime = getEndTime(rangeEnd, interval);
              ranges.push(`${rangeStart}-${endTime}`);
            }

            const dateFormatted = date.replace(/-/g, "/");
            let dateText = dateFormatted;
            if (state.showWeekday) {
              const dateObj = new Date(date + "T00:00:00");
              const weekdays = ["日", "月", "火", "水", "木", "金", "土"];
              const weekday = weekdays[dateObj.getDay()];
              dateText = `${dateFormatted}(${weekday})`;
            }
            results.push(`${dateText} ${ranges.join(",")}`);
          });

        const basicText = results.join("\n");
        if (state.useTemplate) {
          return `〇〇様
お世話になっております。
▲▲です。

この度はMTGのご快諾誠にありがとうございます。
当方の候補日を以下に記載させていただきます。

\\
${basicText}
\\

以上、ご確認のほどよろしくお願いいたします。`;
        }
        return basicText;
      }

      function updateGeneratedText() {
        const text = generateText();
        document.getElementById("output-section").classList.toggle("is-hidden", !text);
        document.getElementById("output-text").textContent = text;
      }

      function updateDisplay() {
        document.getElementById("date-selector").classList.toggle("is-hidden", currentMode !== "daily");
        document.getElementById("current-week-btn").classList.toggle("is-hidden", currentMode !== "weekly");
        document.getElementById("week-nav").classList.toggle("is-hidden", currentMode !== "weekly");
        document.getElementById("daily-section").classList.toggle("is-hidden", currentMode !== "daily");
        document.getElementById("weekly-section").classList.toggle("is-hidden", currentMode !== "weekly");
        updateGeneratedText();
      }

      function goToCurrentWeek() {
        if (!scheduleInstance) return;
        scheduleInstance.goToCurrentWeek();
      }

      // DOMContentLoaded
      document.addEventListener("DOMContentLoaded", function () {
        // Scheduleインスタンス取得
        const scheduleEl = document.querySelector(".wf-schedule");
        scheduleInstance = WFUI.schedule(scheduleEl, {
          mode: "daily",
          timeInterval: 60,
          timeRange: "all-day",
          onSelect: slots => {
            if (slots.length > 0 && !state.isTimeIntervalLocked) {
              state.isTimeIntervalLocked = true;
              state.isTimeRangeLocked = true;
              updateLockControls();
            }
            updateGeneratedText();
          }
        });

        // モード切り替え
        document.getElementById("daily-mode-btn").addEventListener("click", () => {
          currentMode = "daily";
          scheduleInstance.setMode("daily");
          updateModeButtons();
          updateDisplay();
        });

        document.getElementById("weekly-mode-btn").addEventListener("click", () => {
          currentMode = "weekly";
          scheduleInstance.setMode("weekly");
          updateModeButtons();
          updateDisplay();
        });

        // 設定変更
        document.getElementById("selected-date").addEventListener("change", function (e) {
          scheduleInstance.setSelectedDate(e.target.value);
        });

        document.getElementById("time-range").addEventListener("change", function (e) {
          if (!state.isTimeRangeLocked) {
            scheduleInstance.setTimeRange(e.target.value);
            scheduleInstance.clearSelection();
            state.isTimeIntervalLocked = false;
            state.isTimeRangeLocked = false;
            updateLockControls();
          }
        });

        document.getElementById("time-interval").addEventListener("change", function (e) {
          if (!state.isTimeIntervalLocked) {
            scheduleInstance.setTimeInterval(parseInt(e.target.value));
            scheduleInstance.clearSelection();
          }
        });

        document.getElementById("show-weekday").addEventListener("change", function (e) {
          state.showWeekday = e.target.checked;
          updateGeneratedText();
        });

        document.getElementById("use-template").addEventListener("change", function (e) {
          state.useTemplate = e.target.checked;
          updateGeneratedText();
        });

        // アクションボタン
        document.getElementById("clear-btn").addEventListener("click", () => {
          scheduleInstance.clearSelection();
          state.isTimeIntervalLocked = false;
          state.isTimeRangeLocked = false;
          state.rangeSelectionStart = null;
          state.isRangeSelecting = false;
          hideRangeSelectionMessage();
          updateLockControls();
          updateGeneratedText();
        });

        document.getElementById("current-week-btn").addEventListener("click", () => {
          goToCurrentWeek();
        });

        // 週ナビゲーション
        document.getElementById("prev-week-btn").addEventListener("click", () => {
          scheduleInstance.navigateWeek(-1);
        });

        document.getElementById("next-week-btn").addEventListener("click", () => {
          scheduleInstance.navigateWeek(1);
        });

        // コピーボタン
        document.getElementById("copy-btn").addEventListener("click", async () => {
          const text = generateText();
          if (text) {
            try {
              await navigator.clipboard.writeText(text);
              const btn = document.getElementById("copy-btn");
              const textSpan = document.getElementById("copy-text");
              btn.classList.add("wf-btn-success");
              textSpan.textContent = "コピー完了";
              setTimeout(() => {
                btn.classList.remove("wf-btn-success");
                textSpan.textContent = "コピー";
              }, 2000);
            } catch (err) {
              console.error("コピーに失敗しました:", err);
            }
          }
        });

        // 初期値設定
        document.getElementById("selected-date").value = new Date().toISOString().split("T")[0];
        updateModeButtons();
        updateDisplay();

        // Lucide アイコン初期化
        if (typeof lucide !== "undefined") {
          lucide.createIcons();
        }
      });
    </script>
  </body>
</html>
